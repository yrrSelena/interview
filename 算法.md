## 算法

### 二分查找

> https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/er-fen-cha-zhao-suan-fa-xi-jie-xiang-jie-by-labula/

#### 1 排序数组

##### 1.1 特定值

```cpp
int binarySearch(vector<int> nums, int target){
    int left = 0, right = nums.size() - 1;
    while(left <= right){
        int mid = left + (left - right) / 2;
        if(nums[mid] == target) return mid;
        else if(nums[mid] < target) left = mid + 1;
        else right = mid - 1;
    }
    return -1;
}
```

##### 1.2 特定值的边界

[34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

```cpp
//找左边界
int findLeftBound(vector<int> nums, int target){
    int left = 0, right = nums.size() - 1;
    while(left <= right){
        int mid = right + (left - right) / 2;
        if(nums[mid] >= target) right = mid - 1;
        else left = mid + 1;
    }
    return left < nums.size() && nums[left] == target ? left : -1;
}

//找右边界
int findRightBound(vector<int> nums, int target){
    int left = 0, right = nums.size() - 1;
    while(left <= right){
        int mid = right + (left - right) / 2;
        if(nums[mid] <= target) left = mid + 1;
        else right = mid - 1;
    }
    return right >= 0 && nums[right] == target ? right : -1;
}
```

##### 1.3 搜索插入位置

[35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)

```cpp
//找小于目标元素的最大值的位置
int findInsertLoc(vector<int> nums, int target){
    int left = 0, right = nums.size() - 1;
    while(left <= right){
      int mid = right + (left - right) / 2;
      if(nums[mid] == target) return mid;
      else if(nums[mid] < target) left = mid + 1;
      else right = mid - 1;
    }
    return left;
}
```



#### 2 旋转排序数组

##### 2.1 特定值

[33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)

```cpp
int findNum(vector<int> nums, int target){
    int left = 0, right = nums.size() - 1;
    while(left <= right){
        int mid = right + (left - right) /2;
        if(nums[mid] == target) return mid;
        else if(nums[0] <= nums[mid]){
            if(nums[0] <= target && target < nums[mid]) right = mid - 1;
            else left = mid + 1;
        }
        else{
            if(nums[mid] < target && target <= nums[nums.size() - 1]) left = mid + 1;
            else right = mid - 1;
        }
    }
    return -1;
}
```



##### 2.2 旋转点



#### 3 可能存在一个峰值的序列

##### 3.1 峰值



##### 3.2 特定值的最小下标



4 求递增序列





#### KMP

在已匹配的前缀当中寻找最长可匹配后缀子串和最长可匹配前缀子串，在下一轮直接把两者对齐，从而实现模式串的快速移动。

next数组：下标表示已匹配前缀的下一个位置；元素值表示最长可匹配前缀子串的下一个位置



### 动态规划

#### 最长上升子序列

> [300. 最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)
>
> [646. 最长数对链](https://leetcode-cn.com/problems/maximum-length-of-pair-chain/)

**方法一、动态规划**

dp[i]表示以nums[i]为结尾的最长上升子序列长度

$dp[i] = max(dp[i], dp[j] + 1), \ nums[j] < nums[i], j \in [0,i - 1)$

**方法二、贪心+二分查找**

维护一个数组 cell，cell[i] 代表长度为i+1的递增子序列的末尾元素的最小值。（cell为单调递增）

遍历num数组元素，如果nums[i] > cell数组最后一个元素，则向cell数组中加入nums[i]；

否则，二分查找cell数组中第一个比nums[i]大的元素位置loc，并将cell[loc] = nums[i]







