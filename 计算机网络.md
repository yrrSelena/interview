## 计算机网络

https://www.nowcoder.com/discuss/1937

### 网络体系结构

五层协议：应用层、传输层、网络层、数据链路层、物理层

应用进程数据先传送到应用层，再加上应用层首部，成为应用层PDU

应用层PDU传送到传输层，加上传输层首部，成为传输层报文

运输层报文传送到网络层，再加上网络层首部，成为IP数据报（分组）

IP数据报再传送到数据链路层，再加上链路层首部和尾部，形成数据链路层帧

数据链路层帧传送到物理层

由物理层把比特流传送到物理媒体

电/光信号在物理媒体中传播，从发送端物理层传到接收端物理层

##### 协议

- 协议：控制两个对等实体进行通信的规则的集合。（水平的）

- 服务：由下层向上层通过层间接口提供的（垂直的）

- 在协议控制下，两个对等实体间的通信使得本层能够向上一层提供服务

- 要实现本层协议，还需要使用下层所提供的的服务

- 本层服务用户只能看见服务而看不见下面的协议，下面的协议对上面的服务用户是透明的

  

|            |                                                              | 扩展局域网         |
| ---------- | ------------------------------------------------------------ | ------------------ |
| 物理层     | 确定与传输媒体（同轴电缆、光纤、通信卫星、微波等）的接口的一些特性，保证通信信道上传输**比特流** | 集线器             |
| 数据链路层 | 负责在两个相邻结点间的线路上无差错地传送以帧为单位的数据，并进行流量控制（流量控制<由收方控制发方的数据流>、差错处理等） | 网桥、以太网交换机 |
| 网络层     |                                                              | 路由器             |
|            |                                                              | 网关               |
|            |                                                              |                    |

- 集线器使用电子器件来模拟实际电缆线的工作
- 硬件地址/物理地址/MAC地址
- 网桥根据MAC帧的目的地址对收到的帧进行转发。具有过滤帧的功能（先检查帧的目的地址，再确定将该帧转发到哪个端口），在MAC子层没有流量控制功能，只适合用户数不多和通信量不大的局域网，否则会产生广播风暴
- 中间设备：中间系统、中继系统

##### 各层对应的工作设备

物理层：中继器、集线器

数据链路层：网桥、交换机

网络层中继系统：路由器

网络层以上的中继系统：网关



> http://www.ruanyifeng.com/blog/2017/06/tcp-protocol.html

- 以太网协议：规定了电子信号如何组成数据包，解决了子网内部的点对点通信。但以太网协议不能解决多局域网如何互通。

- IP协议：定义了一套自己的地址规则（IP地址），实现了路由功能，允许某个局域网的主机向另一个局域网的主机发送消息

  路由器基于IP协议，局域网之间要靠路由器连接

  路由表注明了不同IP目的地址的数据包要发往哪个网口

- TCP协议：保证数据通信的完整性和可靠性，防止丢包 （缓存满了，新来的数据包就会丢失）

![img](计算机网络.assets/bg20170060810.png)

数据包大小

- 以太网数据包（packet）的大小是固定的，最初是1518字节，后来增加到1522字节。其中， 1500 字节是负载（payload），22字节是头信息（head）

- IP 数据包在以太网数据包的负载里面，它也有自己的头信息，最少需要20字节，所以 IP 数据包的负载最多为1480字节

- TCP 数据包在 IP 数据包的负载里面。它的头信息最少也需要20字节，因此 TCP 数据包的最大负载是 1480 - 20 = 1460 字节。由于 IP 和 TCP 协议往往有额外的头信息，所以 TCP 负载实际为1400字节左右。

  因此，一条1500字节的信息需要两个 TCP 数据包。HTTP/2 协议的一大改进， 就是压缩 HTTP 协议的头信息，使得一个 HTTP 请求可以放在一个 TCP 数据包里面，而不是分成多个，这样就提高了速度。



接收方收到TCP数据包后，由操作系统将其按照顺序组装好（不会处理数据包里的数据），并将组装好的TCP数据包转交给应用程序（端口号用来指定转交给监听该端口的应用程序）

TCP提供表示原始文件大小的机制。应用层协议规定了原文件的大小。如HTTP中头信息`Content-Length`表示信息体的大小



### 数据链路层





### 网络层

实现两个主机之间的通信。真正进行通信的实体是在主机中的进程，是一个主机中的一个进程与另一个主机中的一个进程交换数据。

IP协议虽然能把数据报文送到目的主机，但没有交付给主机的具体应用进程，而端到端的通信才应该是应用进程之间的通信。

网络层上的服务：

|                            | 数据报服务                                        | 虚电路服务                                                   |
| -------------------------- | ------------------------------------------------- | ------------------------------------------------------------ |
| 连接                       | 无连接的                                          | 面向连接的                                                   |
| 思路                       | 可靠通信由用户主机（TCP）保证，网络尽最大努力交付 | 可靠通信由网络保证                                           |
| 端到端的差错处理和流量控制 | 由用户主机负责                                    | 由分组交换网或由用户主机负责                                 |
| 目的站地址                 | 每个分组都携带完整的目的地址                      | 仅在连接建立阶段使用，每个分组使用短的虚电路号，不需要携带完整的目的地址 |
| 分组转发                   | 每个分组独立选择路由进行转发                      | 属于同一条虚电路的分组均按照同一路由进行转发                 |
| 分组顺序                   | 到达目的站时不一定按照发送顺序                    | 总是按照发送顺序到达目的站                                   |
| 当结点发生故障市           | 故障节点可能丢失分组，一些路由可能发生变化        | 所有通过出现故障结点的虚电路均不能工作                       |

- 数据报服务还适合于将一个分组发送到多个地址（广播或多播）
- 流量控制往往指在给定的发送端和接收端之间的点对点通信量的控制，所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收
- 路由器总是具有两个或以上的IP地址，路由器的每个接口都有一个不同网络号的IP地址
- 在同一个局域网上的主机或路由器的IP 地址中的网络号必须是一样的
- 网络层及以上使用IP地址，数据链路层及以下使用硬件地址

##### 地址解析协议（ARP）

- 每个主机都设有一个ARP高速缓存，里面有所在局域网上的各主机和路由器的IP地址到硬件地址的映射表
- 为了减少网络上的通信量，主机A在发送ARP请求分组时，就将自己的IP地址到硬件地址的映射写入ARP请求分组；当主机B收到A的ARP请求分组时，会将主机A的地址映射写入主机B自己的ARP高速缓存中
- 解决同一个局域网上的主机或路由器的IP地址和硬件地址的映射问题

##### 划分子网

IP地址 ::= {<网络号>, <子网号>, <主机号>}  

- 无法从一个IP数据报的首部判断源主机或目标主机所连接的网络是否进行子网划分
- 使用**子网掩码**可找到IP地址中的子网部分
- 先用个网络的子网掩码与收到分组的目的IP地址逐比特相与，看是否和相应的网络地址匹配

### 传输层

#### TCP vs UDP

- TCP是面向连接的、可靠的字节流传输协议（包含建立连接、数据传输、断开连接过程）；UDP是无连接、不可靠的数据发送协议（传输时连接的建立与断开、传输可靠性均有上层应用程序处理）
- TCP是一对一的传输；UDP支持一对一、一对多、多对一、多对多的交互通信
- TCP是面向字节流的（把应用层传来的报文看成字节流，将字节流拆分成大小不等的数据块，并添加TCP首部，首部是20个字节）；UDP是面向报文的，不对应用层传来的报文拆分或合并，只是添加了UDP首部（8个字节）
- TCP保证传输可靠性的方式：确认应答、超时重传、数据有序、流量控制、拥塞控制；UDP仅提供最基础的数据传输能力，发送方根据对方的IP地址发送数据包，但不保证接受发送包的质量，数据无序还容易丢包。虽然UDP协议不稳定但是在即时通讯（QQ聊天、在线视频、网络语音电话）的场景下，可以允许偶尔的断续，但是这种协议开销小、简单、传输速度快。
- TCP对应应用层的协议主要有SMTP(25)、TELNET(23)、HTTP(80)、FTP(21,20)等；UDP对应应用层的协议主要有DNS(53)、TFTP(69)、DHCP、SNMP、NFS等。

#### TCP

> [TCP的三次握手与四次挥手理解及面试题](https://blog.csdn.net/qq_38950316/article/details/81087809?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase)
>
> https://blog.csdn.net/baidu_32045201/article/details/78021536

##### TCP报文首部

![image-20200626111154779](计算机网络.assets\image-20200626111154779.png)

1. 序号seq：4个字节，用于标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生，给字节编上序号后，就给每个报文段指派一个序号；序号seq就是这个报文段中第一个字节的数据编号。（由于TCP数据包大小有限制，TCP传输会将数据拆分为若干个包，因此需要对数据包进行编号，接收方可利用seq进行排序）
2. 确认号ack：4个字节，表示期待收到对方下个报文段的第一个数据字节的序号；当前报文段最后一个字节的编号+1即为确认号
3. 确认ACK：1位，仅当ACK1=1时，确认号字段有效
4. 同步SYN：连接建立时用于同步序号。SYN=1表示这是一个连接请求、连接接收报文。SYN=1, ACK=0：此为连接请求报文段；SYN=1, ACK=1：此为同意连接接收报文。SYN只有在TCP建立连接时才会为1，握手完成后为0。
5. 终止FIN：释放一个连接。FIN=1表示此报文段的发送方和数据已经发送完毕，并要求释放传输连接。

##### TCP可靠传输▲

TCP保证传输可靠性的方式：确认应答、超时重传、数据有序、流量控制、拥塞控制

1. 确认应答：接收方收到报文会进行确认。（ACK携带两个信息：a)期待收到下一个数据包的编号 b)接收方的接收窗口的剩余容量）
2. 丢包处理：如果下个数据包没有收到，那么ack编号不会发生变化。如果发送方发现收到3个连续的重复ACK，或者超时还没收到ACK，就会确认丢包，重新发送数据包
3. 超时重传：TCP发出一个分组后，将启动一个定时器，等待接收端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。 
4. 数据有序：每个数据包中都有序列号，接收端会将接收到的数据包根据序列号进行排序，并且去掉重复序列号的数据。
5. 流量控制：接收方采用滑动窗口控制发送方的发送量，可以防止接收方可用的数据缓冲空间溢出。滑动窗口会指明接收能够接收的最大数据量【接收方能来得及接收】 
6. 拥塞控制：如果网络拥塞，分组将会丢失，此时发送方会重传，导致网络拥塞程度更高。采用“慢启动”、“拥塞避免”、“快速重传 ”、“快速恢复”4种算法控制发送方的速率。【降低整个网络的拥塞程度】
7. 校验和：检验首部和数据



##### 拥塞控制▲

> [TCP的拥塞控制（详解）](https://blog.csdn.net/qq_41431406/article/details/97926927)

为了进行拥塞控制，TCP发送方要维持一个**拥塞窗口**(cwnd)的状态变量，其大小取决于网络的拥塞程度，并动态变化。发送方让自己的发送窗口=min(拥塞窗口,接收窗口)
![在这里插入图片描述](计算机网络.assets/20190731165743903.png)

- 慢开始：当主机开始发送数据时，如果立即把大量数据字节注入到网络，可能会引起网络阻塞。先探测以下，由小到大逐渐增大发送窗口<拥塞窗口数值cwnd>，cwnd初值为1，每经过一个传播轮次（RTT时间），cwnd加倍（1,2,4,8,16,..呈指数增长）
- 拥塞避免：让拥塞窗口cwnd缓慢增大，每经过一个往返时间RTT就把发送方的cwnd+1（线性增长）
- 快重传：让发送方尽快进行重传，而不是等超时重传计时器超时再重传
- 快恢复：发送方一旦收到3个重复确认，就知道现在只是丢失了个别报文段，于是不启动慢开始算法，而执行快恢复算法。

- 发送方将慢开始门限ssthresh以及cwnd都设为当前窗口的一半，并开始执行拥塞避免算法

慢开始门限ssthresh

- 当cwnd<ssthresh：采用慢开始算法
- 当cwnd>ssthresh：采用阻塞避免算法
- 当发送方超时重传，则误以为网络发送拥塞，将ssthresh设为发生拥塞时cwnd的一半，并将cwnd重置为1，重新采用慢开始算法

##### 拥塞控制 vs 流量控制

- 流量控制：**控制发送方发送速率，保证接收方来得及接收**。TCP利用滑动窗口实现流量控制。（接收方发送的ACK报文中的窗口字段可以用来控制发送方窗口大小）<点对点通信量的控制，是端到端的问题>
- 拥塞控制：**降低整个网络的拥塞程度，防止过多的数据注入到网络中，使网络中的路由器或链路不至于过载。**<是全局性过程，涉及所有主机、路由器以及于降低网络传输性能有关的所有因素>（拥塞：对网络中某一资源的需求超过该资源所能提供的可用部分，网络的性能可能就要变坏）



##### 三次握手（建立连接）▲

刚开始客户端处于closed状态，服务端处于listen状态

1. 第一次握手：客户端给服务器端发送一个**SYN报文**，并指明客户端的初始化序列号seq=x（SYN=1,ACK=0,seq=x）。此时客户端处于SYN_Send<同步已发送>状态。
   - SYN报文段不能携带数据，但需要消耗一个序号
2. 第二次握手：服务器收到客户端的SYN报文后，发送**SYN+ACK**报文，会以自己的SYN报文作为应答，同时也指定了自己的初始化序列号seq=y（SYN=1,ACK=1,seq=y,ack=x+1），同时会把客户端的序列号x+1作为确认号ack，表示自己已经收到了客户端的SYN，此时服务器处于SYN_REVD<同步收到>状态
3. 第三次握手：客户端收到SYN+ACK报文后，会发送一个**ACK报文**（ack=y+1），表示已经收到了服务器端的SYN报文，此时客户端处于established<已建立连接>状态（TCP连接成功）
   - ACK报文段可以携带数据，如果不携带数据则不消耗序号
4. 服务器端收到ACK报文后，也处于established状态，此时双方建立起了连接，客户端和服务器端可以正式开始传送数据

SYN只有在TCPTCP 建立连接时才为1，握手完成后为0

##### 四次挥手（终止连接）▲

1. 第一次挥手：客户端发送一个**FIN报文**，报文中会指定一个序列号（seq=u,FIN=1,u=前面已经传来的数据的最后一个字节的序号+1）。此时客户端处于FIN_WAIT1状态。
   - FIN报文段即使不携带数据，也要消耗一个序号
2. 第二次挥手：服务器端收到FIN报文后，会发送**ACK报文**，且把客户端的序列号+1作为ACK报文，表明已经收到客户端的报文了（seq=v,ACK=1,ack=u+1），此时服务器端处于CLOSE_WAIT状态。
   - TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时处于半关闭状态（客户端已经没有要发送的数据了，但服务器若发送数据，客户端仍要接收。整个状态需要持续一段时间，也就是整个CLOSE_WAIT持续的时间）
3. 客户端收到服务器的ACK报文后，就进入FIN_WAIT2状态，等待服务器端发送FIN报文（在这之前还需要接受服务器端发送的最后的数据）
4. 第三次挥手：如果服务器端将最后的数据发送完毕后，也想断开连接了，就和客户端的第一次挥手一样，发出**FIN报文**，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为w（FIN=1,seq=w,ack=u+1）。此时服务器端处于LAST_ACK状态等待客户端的确认。
5. 第四次挥手：客户端收到FIN报文后，同样发送一个**ACK报文**作为应答（ACK=1,seq=u+1,ack=w+1），此时客户端处于TIME_WAIT状态。【注】此时TCP连接还未释放，需要经过2xMSL（最长报文段寿命）的时间后，确保服务器端收到自己的ACK报文后才进入CLOSED状态。（seq=x,ack=y）
6. 服务器端收到ACK报文后，就立即关闭连接，处于CLOSED状态。（可以看出，服务器结束TCP连接的时间比客户端早一些）

##### 为什么TCP不是两次握手or四次握手？ 

> [TCP的三次握手与四次挥手理解及面试题（很全面）](https://blog.csdn.net/qq_38950316/article/details/81087809?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase)

**为什么不是两次握手？**

- **防止失效的连接请求报文段被服务端接收而产生错误。**<失效的连接请求：若客户端向服务端发送的连接请求丢失，客户端等待应答超时后就会再次发送连接请求，此时上一个连接请求就是**失效的**>
  若建立连接只进行两次握手，那客户端没有太大变化，仍需要获得服务器应答后才进入establish状态，而服务器段在收到连接请求后就进入establish状态。若此时网络拥塞，客户端发送的连接请求迟迟到不了服务器，客户端就会超时重发请求，如果服务端正确接收并确认应答，双方便开始通信，通信结束后会释放连接。此时如果那个失效的连接请求到达服务端，由于只有两次握手，服务端收到请求后进入establish状态，会等待发送数据或主动发送数据。但此时客户端早已进入closed状态，那么服务器端将会一直等下去，会浪费服务端的连接资源。
- 双方都需要确认对方收到了自己发送的序列号

**为什么是四次挥手?**

- 建立连接时，服务器端可以直接发送SYN+ACK报文
- 关闭连接时，服务器端会先回复一个ACK报文，但可能还需要发送一些数据后再发送FIN报文，表示同意关闭连接。因此，ACK报文和FIN报文往往是分开发送的。

TCP 三次握手和四次挥手。TIME_WAIT 为什么是 2MSL 而不是 1MSL 或者 3MSL？

##### TIME_WAIT 

2MSL就是一个发送和一个回复所需的最大时间。

TIME_WAIT状态就是用来重发可能丢失的ACK报文

- 保证客户端发送的最后一个ACK报文能达到服务器。（如果网络不可靠，可能会丢失最后的ACK报文。如果在2MSL内客户端再次收到FIN，那么会重发并再次等待2MSL。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。）
- 防止类似三次握手中提到的“已失效的连接请求报文段”出现。可能会在相同的IP地址和端口建立新的连接，为了防止新连接中出现旧连接的请求报文。客户端发送完最后的ACK报文后，在2MSL时间内，可以使本连接持续时间内所产生的所有报文段从网络中消失。

##### TCP keep alive

<u>解决已经建立了连接，但是客户端突然出现故障的情况。</u>为防止资源浪费，TCP还设有一个保活计时器。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。


- ping:用来测试两个主机之间的连通性，是应用层直接使用网络层ICMP的例子，没有通过传输层TCP或UDP



#### socket

> https://blog.csdn.net/codedoctor/article/details/87978716

![image](计算机网络.assets/socket3.jpg)

socket：创建一个socket并返回socket描述符（与普通文件打开类似）

bind：服务器在启动时会绑定一个众所周知的地址（IP+端口号）用于提供服务。由于客户端不用指定，在connect时由系统随机生成

accept：服务端接收到请求会调用accept表示同意请求





### 应用层

|        |                |      | 端口号 |                                                              |
| ------ | -------------- | ---- | ------ | ------------------------------------------------------------ |
| SMTP   | 邮件传送协议   |      |        | 发信人的用户代理向源邮件服务器发送邮件，以及源邮件服务器向目的邮件服务器发送邮件，都是使用 SMTP 协议 |
| POP    | 邮件读取协议   |      |        | 用户从目的邮件服务器上读取邮件所使用的协议                   |
| IMAP   | 邮件读取协议   |      |        | 用户从目的邮件服务器上读取邮件所使用的协议                   |
| FTP    | 文件传送协议   | TCP  | 21,20  | 将文件从一台计算机复制到另一台可能相距很远的计算机（FTP使用了两个不同的端口号，所以数据连接与控制连接不会发生混乱） |
| TFTP   | 文件传送协议   | UDP  | 69     | 只支持文件传输而不支持交互                                   |
| TELNET | 远程终端协议   | TCP  |        | 用户在其所在地通过 TCP 连接注册（即登录）到远地的另一个主机上（使用主机名或IP地址） |
| HTTP   | 超文本传送协议 | TCP  | 80     |                                                              |
| SNMP   | 网络管理协议   | UDP  |        |                                                              |

- #### 浏览器输入一个URL到页面加载的过程▲

  > [从输入URL到页面加载发生了什么](https://segmentfault.com/a/1190000006879700)

  1. DNS解析
  2. 三次握手建立TCP连接
  3. 客户端发送HTTP请求
  4. 服务器处理请求并返回HTTP报文
  5. 浏览器解析渲染页面
  6. 连接结束

  #### DNS解析（采用UDP）

  首先在浏览器dns缓存中寻找是否有解析的ip地址，如果没有，则在本机hosts文件中找；如果还没有，则请求本地域名系统解析域名，如果本地域名系统的缓存中没有相应的ip地址，那么本地域名系统则会依次向根域名系统、顶级域名系统、次域名系统进行逐级迭代查询，最后本地域名系统会将URL对应的IP地址返回给主机。

  #### HTTP 包结构

  HTTP是无状态的协议

  - 定义：用于HTTP协议交互的信息被称为HTTP报文，HTTP报文本身是由多行数据构成的字符串文本。（HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。）

  - 结构（HTTP报文由**报文首部**和**报文主体**构成，中间由一个空行(CRLF)分隔。）

    1. 报文首部：是客户端或服务器端需处理的响应或请求的内容及属性，可以传递额外的重要信息。
    2. 空行（回车+换行 CR+LF）
    3. 报文主体：包含应被发送的数据。通常不一定由报文主体。

  - 类别：

    1. **请求报文**：客户端的HTTP报文

       - 请求行：请求方法 URI资源位置 HTTP协议版本，用空格分开
         `GET /index.html HTTP/1.1`
       - 请求头部：描述请求正文，用于说明请求源、连接类型及Cookie信息等
       - 空行
       - 请求正文：一般用于存放POST请求类型的请求正文，如`username=jack&sex=man`

       ![image-20200809130154118](计算机网络.assets/image-20200809130154118.png)

       ![image-20200809130205957](计算机网络.assets/image-20200809130205957.png)

    2. **响应报文**：服务器端的HTTP报文

       - 状态行：HTTP版本 响应返回状态码 响应描述

    - 响应头部：返回服务器的基本信息，及Cookie值等

    - 空行

      - 响应体：为请求需要得到的具体数据，可以是任何类型，网页浏览一般返回html文件内容


        ![image-20200809130218521](计算机网络.assets/image-20200809130218521.png)

  #### HTTP 请求方法▲

  GET：从服务器端获取数据（幂等的）

  HEAD：类似于 GET 请求，用于获取报头，不返回消息正文。用于检查资源/超链接的有效性

  POST：向服务器端上传数据

  PUT：从客户端向服务器端传送的数据取代指定文档的内容（幂等的）

  DELETE：请求服务器删除指定页面

  OPTIONS：

  ##### GET vs POST▲

  - GET是从服务器上获取数据（即下载），POST是向服务器传送数据（即上传）

  - GET参数通过URL传递，POST放在Request body中 （GET传递的请求数据按照key-value的方式放在URL后面，在网址中可以直接看到，使用?分割URL和传输数据，传输的参数之间以&相连，如：login.action?name=user&password=123,安全性差。POST会把请求的参数放到请求正文中以&分隔各个字段，URL中不会额外附带参数，安全性高。)

  - 发送数据大小：GET有限制，POST无。(不同浏览器对请求的处理方式不同，大多数浏览器会限制URL的长度)

  - 对参数的数据类型，GET只接受ASCII字符，而POST没有限制

  - GET产生一个TCP数据包；POST产生两个TCP数据包。

    对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。

  - <u>GET是安全的和幂等的</u>（安全的：操作用于获取信息而非修改信息，幂等的：对同一 URL 的多个请求应该返回同样的结果）

  

  

  #### http1.0 vs http1.1 vs http2.0

  - http1.0：短连接，连接无法复用。浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接。

  - http1.1：

    1. 长连接，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。`Connection=Keep-Alive`
    2. Host头：HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名，现在有了虚拟主机技术，一台服务器上可以多个虚拟主机，有了host字段可以将请求发给同一台服务器上的不同站点
    3. 支持断点续传 `range:bytes`,可以要求服务器从文件的某个字节处开始传送

  - http2.0：

    1. 二进制分帧层：http1.0，1.1的头信息是基于文本的ASCII码，而http2.0的报头和报文主体都是二进制码

       http2.0把HTTP通信的基本单位缩小为帧，把首部信息放到header帧，主体信息放到data帧

    2. 多路复用：在一个连接里，客户端和浏览器都可以同时发送多个请求和响应，而不用按照顺序一一对应，这样避免了“队头堵塞”并行地在同一个 TCP 连接上双向交换消息（http1.1中浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻塞）。

    3. header压缩：header带有大量的信息，且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。

    4. **服务端推送**（server push），把客户端所需要的资源伴随着index.html一起发送到客户端。比如客户端的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了

  ##### 长连接 短连接

  - 短连接：假设有一个网页，里面包含好多图片，还包含好多**外部的**CSS 文件和 JS 文件。在“短连接”的模式下，浏览器会先发起一个 TCP 连接，拿到该网页的 HTML 源代码（拿到 HTML 之后，这个 TCP 连接就关闭了）。然后，浏览器开始分析这个网页的源码，知道这个页面包含很多外部资源（图片、CSS、JS）。然后针对**每一个**外部资源，再分别发起一个个 TCP 连接，把这些文件获取到本地（同样的，每抓取一个外部资源后，相应的 TCP 就断开）

    HTTP1.0默认使用短连接

  - 长连接：浏览器也会先发起一个 TCP 连接去抓取页面。但是抓取页面之后，该 TCP 连接并不会立即关闭，而是暂时先保持着（所谓的“Keep-Alive”）。然后浏览器分析 HTML 源码之后，发现有很多外部资源，就用刚才那个 TCP 连接去抓取此页面的外部资源。

    HTTP1.1默认采用长连接

  #### Cookie vs Session

  http无状态。既然服务器没有记忆能力，它就无法支持需要连续多个步骤的`事务`操作。每次都得问一遍身份信息，不仅麻烦，而且还增加了不必要的数据传输量。由此出现了 `Cookie` 技术。

  - cookie数据存放在客户的浏览器上，session数据放在服务器上（在服务端保存的用来跟踪用户的状态的数据结构）
  - Cookie 支持跨域名访问，例如，将 domain 属性设置为“.biaodianfu.com”，则以“.biaodianfu.com”为后缀的一切域名均能够访问该Cookie。跨域名Cookie如今被普遍用在网络中，例如，Google、Baidu、Sina等。
  - cookie安全性一般，可用过分析存放在本地的cookie进行欺骗。重要交互信息比如权限等就要放在Session中，一般的信息记录放Cookie就好了。
  - 单个Cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个Cookie
  - 每次HTTP请求时，客户端都会发送相应的Cookie信息到服务端。
  - session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用cookie。
  - 用户验证这种场合一般会用 Session。因此，维持一个会话的核心就是客户端的唯一标识，即Session ID。

  在浏览器关闭后这次的Session就消失了，下次打开就不再拥有这个Session。其实并不是Session消失了，而是Session ID变了，服务器端可能还是存着你上次的Session ID及其Session 信息，只是他们是无主状态，也许一段时间后会被删除。

  目前大多数的应用都是用Cookie 实现Session跟踪的。第一次创建Session时，服务端会通过在HTTP协议中反馈到客户端，需要在 Cookie 中记录一个Session ID，以便今后每次请求时都可分辨你是谁。有人问，如果客户端的浏览器禁用了 Cookie 怎么办？建议使用URL重写技术进行会话跟踪，即每次HTTP交互，URL后面都被附加上诸如 sid=xxxxx 的参数，以便服务端依此识别用户。

  #### HTTP 状态码▲

  状态码是用来告知客户端服务器端处理请求的结果。

  状态码是由3位数组成，第一个数字定义了响应的类别，且有五种可能取值:

  - 1xx：通知–表示请求已接收，继续处理。
  - 2xx：成功–表示请求已被成功接收、理解、接受。
  - 3xx：重定向–要完成请求必须进行更进一步的操作。
  - 4xx：客户端错误–请求有语法错误或请求无法实现。
  - 5xx：服务器端错误–服务器未能实现合法的请求。

  平时遇到比较常见的状态码有:200（客户请求成功），201（服务器按照客户端的请求创建了一个新资源）, 204, 301（请求永久重定向，该状态码表示请求的资源已经被分配了新的URL，以后应该使用资源现在指定的URL）, 302（请求临时重定向）, 304, 400, 401, 403（forbidden表明请求访问的资源被拒绝了）, 404, 422, 500, 503 。

  

  #### http vs https▲

  - http(Hypertext transfer protocol)超文本传输协议，通过浏览器和服务器进行数据交互，进行超文本（文本、图片、视频等）传输的规定。也就是说，http协议规定了超文本传输所要遵守的规则。

  - https：在http(超文本传输协议)基础上提出的一种安全的http协议，因此可以称为安全的超文本传输协议。http协议直接放置在TCP协议之上，而https提出在http和TCP中间加上一层加密层。从发送端看，这一层负责把http的内容加密后送到下层的TCP，从接收方看，这一层负责将TCP送来的数据解密还原成http的内容。

    1、https协议需要到CA申请证书，一般免费证书较少，因而需要一定费用。
    2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
    3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
    4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

  #### https安全

  - http是明文传输，而网络请求中间有很多的服务器路由器的转发，之间的结点都可能监听、伪装、篡改信息。

    - 监听：通信内容被获取。数据在客户端与服务端通信过程中，任何一点都可能被劫持（eg.发送了银行卡号和密码，中间人劫取数据就能看到卡号和密码）
    - 伪装：冒充他人身份参与通信。http通信时，无法保证通信双方是合法的，通信方可能是伪装的（eg.修改用户的请求头URL，导致用户的请求被劫持到另一个网址，导致用户的请求到不了真正的服务器）
    - 篡改：通信内容被修改。接收方不知道数据已经被中间人篡改（eg. 中间人将广告链接嵌入到服务器发送给用户的http报文里，导致用户界面出现不良链接）

  - 而https在http加了一个安全协议(SSL/TSL<Transport Layer Security,传输层安全协议>)，保证传输安全，防止传输过程被监听、防止数据被窃取，可以确认网站的真实性。

    通过数据加密、校验数据完整性和身份认证三种机制来保障安全

    - 防监听：数据加密，监听到的是密文
    - 防伪装：通信双方携带证书（相当于身份证），有证书认为是合法的，无证书非法（证书由第三方颁布，难以伪造）
    - 防篡改：https对数据做了摘要，篡改数据会被发现

  #### 加密算法

  - 对称加密：
    - 加密解密采用同样的密钥
    - 计算量小、加密速度快、效率高
    - 常见算法由：AES、DES
  - 非对称加密：使用了一对密钥，公钥和私钥。（RSA）
    公钥是公开的，任何人/客户端都可以获取，客户端使用公钥加密数据，服务端用私钥解密数据
  - 摘要算法：经过算法运算后生成固定长度的数据，是不可逆的过程。主要用于验证消息完整性（每个数据生成的MD5值不同）、安全访问认证（账号登录的密码）、数字签名（结合非对称加密算法和CA证书）
    - MD5：将任意长度的字符串转变为128位的大整数，是不可逆的字符串变换算法（无法将一个MD5的值转变回原始的字符串），速度快
  - SHA1:160位，强度更高

  #### https整个加密过程▲

  > http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html

  SSL： 在传输层。在TCP协议之上，应用层之下运作，是用来传输敏感信息的。使用SSL连接的URL地址以https开头，而不是http。
  优点： 非对称加密只使用了一次，后续所有的通信消息都是用对称加密，效率比非对称加密高。

  - 服务器端需要认证的通信过程

    1. 客户端发起 HTTPS 请求，包含(a)一个客户端生成的随机数(Client random) (b)客户端支持的加密协议及(c)支持的协议版本（SSL/TLS）

       客户端(如浏览器)对一些加解密算法的支持程度不一样，但是在TLS协议传输过程中必须使用同一套加解密算法才能保证数据能够正常的加解密。在TLS握手阶段，客户端首先要告知服务端，自己支持哪些加密算法，所以客户端需要将本地支持的加密套件(Cipher Suite)的列表传送给服务端。

    2. 服务端返回证书，包含(a)服务器证书<包含公钥>(b)一个服务器端生成的随机数(Server random)(c)确认使用的加密通信协议版本(d)确认使用的加密方法

    3. 客户端使用根证书验证证书合法性，验证通过后，客户端生成一个新的随机数(Premaster secret)，通过证书中的公钥对其进行加密，发送到服务端

       浏览器判断证书发布者CA是否属于系统中内置的受信任的证书发布机构，校验证书的合法性->取出公钥对证书里的签名进行解密->使用相同的hash算法计算证书的hash值，并将计算得到的hash值与证书中的签名对比

    4. 服务端使用私钥解密得到随机数(Premaster secret)

    5. 客户端和服务器端使用前面的三个随机数，生成对话密钥(session key)，握手之后的对话使用对话密钥加密（对称加密）对称密钥解密数据

    6. SSL加密建立（之后的数据交互通过对称加密算法进行加解密）

  - 客户端需要认证的通信过程
    支付宝、银行客户端等金融应用需要在客户端安装证书

  HTTPS= 数据加密+网站认证+完整性验证+HTTP

  对称加密的缺点：

  （1）不同的客户端、服务器数量庞大，所以双方都需要维护大量的密钥，维护成本很高

  （2）因每个客户端、服务器的安全级别不同，密钥极易泄露

  

  >  [拓]12306刚上线的时候，有证书，为什么还提示证书不可信呢  [字客1]

SSL（安全套接层，Secure Socket Layer），可对万维网客户与服务器之间传送的数据进行加密和鉴别

- 在发送方，SSL 接收应用层的数据（如 HTTP 或 IMAP 报文），对数据进行加密，然后将加了密的数据送往 TCP 插口。
- 在接收方，SSL 从 TCP 插口读取数据，解密后将数据交给应用层。