## 操作系统

#### 进程vs线程

1. 进程是操作系统资源分配的最小单位，线程是CPU任务调度的最小单位。一个进程可以包含多个线程，所以进程和线程都是一个时间段的描述，是CPU工作时间段的描述，不过是颗粒大小不同。
2. 不同进程间数据很难共享，同一进程下不同线程间数据很易共享。
3. 每个进程都有独立的代码和数据空间，进程要比线程消耗更多的计算机资源。线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器，线程之间切换的开销小。
4. 进程间不会相互影响，一个线程挂掉将导致整个进程挂掉。
5. 系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源。
6. 线程可以直接与进程内的其它线程通信，进程间通过IPC（Inter-Process communication，进程间通信）通信

#### 进程的组成部分

进程由进程控制块（PCB）、程序段、数据段三部分组成。

#### 进程的通信方式(IPC)

1.无名管道（pipe），2.命名管道（FIFO），3.消息队列（msg），4.共享内存（shm），5.信号量（sem），6.socket

>  [进程间的五种通信方式介绍](https://www.cnblogs.com/zgq0/p/8780893.html)
>
> [进程间通信及使用场景](https://www.jianshu.com/p/4989c35c9475)
>
> [进程 第二天 (fork函数&子进程与父进程&守护进程)](https://blog.csdn.net/nan_lei/article/details/81636473)
>
> [unix系统下用fork生成一个父进程和多个子进程](https://segmentfault.com/a/1190000019820126)
>
> [面试必问：七大进程间通信和线程同步](https://www.nowcoder.com/discuss/443829?channel=666&source_id=home_feed)

1. 无名管道：

   - 半双工的，即数据只能在一个方向上流动，具有固定的读端和写端
   - 只能用于具有亲缘关系的进程之间的通信（父子进程或兄弟进程之间）
   - 可以看成是一种特殊的临时文件，对于它的读写也可以使用普通的read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于**内存**中。
   - 当一个管道建立时，会创建两个文件描述符，fd[0]为读而打开，fd[1]为写而打开

   ```c
   /*无名管道pipe
   #include<unistd.h>
   int pipe(int fd[2]); 成功返回0，失败返回-1
   */
   #include<stdio.h>
   #include<unistd.h>
   int main()
   {
       int fd[2];  // 两个文件描述符
       pid_t pid;
       char buff[20];
   
       
       if(pipe(fd) < 0)  // 创建管道
           printf("Create Pipe Error!\n");
       //根据fork函数的返回值判断父/子进程
       //fork返回：0表示子进程，>0表示父进程，-1表示进程创建失败
       if((pid = fork()) < 0)  // 创建子进程
           printf("Fork Error!\n");
       else if(pid > 0)  // 父进程
       {
           close(fd[0]); // 关闭读端
           write(fd[1], "hello world\n", 12);
       }
       else
       {
           close(fd[1]); // 关闭写端
           read(fd[0], buff, 20);
           printf("%s", buff);
       }
   
       return 0;
   }
   ```

   - 通常调用pipe的进程会接着调用fork，以此创建父进程和子进程之间的IPC通道
   - 调用fork()函数前是一个进程在执行这段代码，调用fork()函数后是两个进程在执行这段代码（在父进程中，fork函数会将子进程的PID返回给父进程<父进程的pid变量值为大于0的整数>，子进程中，fork函数返回0，即子进程的pid变量值为0）
   - 若要数据流从父进程流向子进程，则关闭父进程的读端(fd[0])与子进程的写端(fd[1])；反之可以使数据流从子进程流向父进程

2. FIFO命名管道：FIFO是一种文件类型

   - 可以在无关的进程之间交换数据，与无名管道不同
   - FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。
   - FIFO的通信方式类似于在进程中使用文件来传输数据，只不过FIFO类型文件同时具有管道的特性。在数据读出时，FIFO管道中同时清除数据，并且“先进先出”。
   - 可以扩展成“**客户进程—服务器进程**”通信的实例，`write_fifo`的作用类似于客户端，可以打开多个客户端向一个服务器发送请求信息，`read_fifo`类似于服务器，它实时监控着FIFO的读端，当有数据时，读出并进行处理。（客户请求：客户将请求写到服务器进程创建的“众所周知”的FIFO接口<每个客户进程在其请求中包含自身进程ID>，服务器回应：服务器为每个客户进程创建一个FIFO用于回应）

   ```c
   /*
   #include<sys/stat.h>
   int mkfifo(const char *pathname, mode_t mode);
   */
   ```

   

3. 消息队列（msg）

   - 消息队列，是消息的链接表，存放在**内核**中。一个消息队列由一个标识符（即队列ID）来标识。
   - 面向记录，其中的消息具有特定的格式以及特定的优先级
   - 独立于发送和接受进程。进程终止时，消息队列及其内容不会被删除
   - 可以实现消息的随机查询，消息不一定要以先进先出的次序读取，可以按消息的类型读取

   ```c
   /*
   #include<sys/msg.h>
   int msgget(key_t key, int flag); //创建或打开消息队列，成功：队列ID，失败：-1
   int msgsnd(int msqid, const void *ptr, size_t size, int flag); //添加消息，成功：0，失败：-1
   int msgrve(int msqid, void *ptr, size_t size, long type, int flag);//读取消息，成功：消息数据的长度，失败：-1
   int msgctl(int msqid, int cmd, struct msqid_ds *buf);//控制消息队列，成功：0，失败：-1
   */
   ```

4. 信号量（semaphore）：

   - 信号量是一个计数器，信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。
   - 用于进程间同步，若要在进程间传递数据，需要结合共享内存
   - 信号量基于操作系统的PV操作，程序对信号量的操作都是原子操作
   - 每次对信号量的PV操作不仅限于对信号量值+1/-1，也可以加减任意正整数（信号量值为正：进程可以使用该资源，此时进程会将信号值-1，表示他已使用了一个资源单位；信号量值为0：进程进入休眠状态，直至信号量值大于0，被唤醒。当进程不再使用由信号量控制的共享资源时，信号量+1）
   - 支持信号量组

   ```c
   /*
   #include <sys/sem.h>
   // 创建或获取一个信号量组：若成功返回信号量集ID，失败返回-1
   int semget(key_t key, int num_sems, int sem_flags);
   // 对信号量组进行操作，改变信号量的值：成功返回0，失败返回-1
   int semop(int semid, struct sembuf semoparray[], size_t numops);  
   // 控制信号量的相关信息
   int semctl(int semid, int sem_num, int cmd, ...);
   */
   ```

   

5. 共享内存（shm, shared memory）

   - 共享内存指两个或多个进程共享一个给定的存储区，一般配合信号量使用。

   - 最快的一种IPC，进程直接对内存进行存取，不需要在客户进程和服务器进程之间复制

   - 多个进程可以同时操作，需要用信号量同步对共享内存的访问。比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存。

     ```c
     /*
     #include <sys/shm.h>
     // 创建或获取一个共享内存：成功返回共享内存ID，失败返回-1
     int shmget(key_t key, size_t size, int flag);
     // 连接共享内存到当前进程的地址空间：成功返回指向共享内存的指针，失败返回-1
     void *shmat(int shm_id, const void *addr, int flag);
     // 断开与共享内存的连接：成功返回0，失败返回-1
     int shmdt(void *addr);
     // 控制共享内存的相关信息：成功返回0，失败返回-1
     int shmctl(int shm_id, int cmd, struct shmid_ds *buf);
     */
     ```

   - 当用`shmget`函数创建一段共享内存时，必须指定其 size；而如果引用一个已存在的共享内存，则将 size 指定为0 。

   - 当一段共享内存被创建以后，它并不能被任何进程访问。必须使用`shmat`函数连接该共享内存到当前进程的地址空间，连接成功后把共享内存区对象映射到调用进程的地址空间，随后可像本地空间一样访问。

   - `shmdt`函数是用来断开`shmat`建立的连接的。注意，这并不是从系统中删除该共享内存，只是当前进程不能再访问该共享内存而已。

   - `shmctl`函数可以对共享内存执行多种操作，根据参数 cmd 执行相应的操作。常用的是`IPC_RMID`（从系统中删除该共享内存）。

【例】共享内存+信号量+消息队列

- 共享内存：传递数据
- 信号量：同步
- 消息队列：客户端修改共享内存后通知服务器读取

#### 进程间通信方式的比较

|            | 优缺点                                                       | 应用场景                      |
| ---------- | ------------------------------------------------------------ | ----------------------------- |
| 管道       | 速度慢，容量有限，单向通信，只有父子进程能通讯               |                               |
| FIFO       | 任何进程间都能通讯，但速度慢                                 | 实现“客户进程-服务器进程”通信 |
| 消息队列   | 容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题（可实现多对对，需在内存中实现） |                               |
| 信号量     | 不能传递复杂消息，只能用来同步                               |                               |
| 共享内存区 | 能够很容易控制容量，速度快，但要保持同步                     |                               |
| socket     | 能够实现网络中进程间通信                                     |                               |



#### 死锁的4个必要条件

1. 互斥条件：一个资源每次只能被一个线程使用；
2. 请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放；
3. 不剥夺条件：进程已经获得的资源，在未使用完之前，不能强行剥夺；
4. 循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。

#### 如何避免（预防）死锁

1. 破坏“请求和保持”条件：让进程在申请资源时，一次性申请所有需要用到的资源，不要一次一次来申请，当申请的资源有一些没空，那就让线程等待。不过这个方法比较浪费资源，进程可能经常处于饥饿状态。还有一种方法是，要求进程在申请资源前，要释放自己拥有的资源。
2. 破坏“不可抢占”条件：允许进程进行抢占，方法一：如果去抢资源，被拒绝，就释放自己的资源。方法二：操作系统允许抢，只要你优先级大，可以抢到。
3. 破坏“循环等待”条件：将系统中的所有资源统一编号，进程可在任何时刻提出资源申请，但所有申请必须按照资源的编号顺序提出（指定获取锁的顺序，顺序加锁）。

![image-20200626111256937](\操作系统.assets\image-20200626111256937.png)





##### 同步 异步 阻塞 非阻塞

- 同步：